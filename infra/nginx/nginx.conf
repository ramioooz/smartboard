# ─────────────────────────────────────────────────────────────────────────────
# Smartboard — Nginx reverse proxy / load balancer
#
# Sits in front of one or more gateway replicas.
# Scale the gateway with:
#   docker compose -f infra/compose.yaml up -d --scale gateway=3
#
# Traffic flow:
#   Browser/cURL → nginx:80 → round-robin → gateway:4000 (N replicas)
# ─────────────────────────────────────────────────────────────────────────────

# Docker's embedded DNS — required so nginx re-resolves "gateway" on every
# request and picks up new replicas added by --scale without restarting nginx.
resolver 127.0.0.11 valid=10s ipv6=off;

server {
    listen 80;
    server_name _;

    # ── Common proxy headers ──────────────────────────────────────────────────
    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    # Forward the nginx-generated request id so the gateway can log it
    proxy_set_header X-Request-Id      $request_id;

    # ── SSE stream — /api/realtime/* ─────────────────────────────────────────
    # Server-Sent Events require:
    #   1. HTTP/1.1 keep-alive to upstream
    #   2. Proxy buffering OFF — otherwise frames are held until the buffer fills
    #   3. Long read timeout — SSE connections stay open for minutes/hours
    location /api/realtime/ {
        set $upstream http://gateway:4000;
        proxy_pass $upstream;

        proxy_set_header   Connection '';   # keep-alive (no Upgrade)
        proxy_buffering    off;
        proxy_cache        off;
        proxy_read_timeout 86400s;          # 24 h — persistent SSE connections
        proxy_send_timeout 86400s;
        proxy_connect_timeout 5s;
    }

    # ── Everything else ───────────────────────────────────────────────────────
    # Using $upstream variable (not a static upstream{} block) forces nginx to
    # re-resolve "gateway" via Docker DNS on each request, which distributes
    # load across all replicas returned by the embedded DNS round-robin.
    location / {
        set $upstream http://gateway:4000;
        proxy_pass $upstream;

        proxy_set_header  Connection '';
        proxy_read_timeout  30s;
        proxy_connect_timeout 5s;
    }
}
